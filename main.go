package main

import (
	"bufio"
	"bytes"
	"errors"
	"flag"
	"fmt"
	"go/build"
	"io"
	"log"
	"os"
	"path/filepath"
	"strconv"
	"strings"
	"unicode/utf8"

	"github.com/koron-go/srcdom"
	"golang.org/x/tools/imports"
)

type errs []error

func (e *errs) Append(err error) {
	*e = append(*e, err)
}

func (e errs) Error() string {
	if len(e) == 0 {
		return "no errors"
	}
	b := &strings.Builder{}
	fmt.Fprintln(b, "found some errors:")
	for i, err := range e {
		fmt.Fprintf(b, "#%d - %v\n", i+1, err)
	}
	return b.String()
}

type variable struct {
	name string
	typ  string
}

type vars []*variable

func (vv *vars) add(v *variable) {
	*vv = append(*vv, v)
}

func (vv vars) nameTypes() string {
	return vv.join(func(v *variable) string {
		return v.name + " " + v.typ
	})
}

func (vv vars) names() string {
	return vv.join(func(v *variable) string {
		return v.name
	})
}

func (vv vars) namesPrefix(prefix string) string {
	return vv.join(func(v *variable) string {
		return prefix + "." + v.name
	})
}

func (vv vars) types() string {
	return vv.join(func(v *variable) string {
		return v.typ
	})
}

func (vv vars) join(fn func(v *variable) string) string {
	b := &strings.Builder{}
	for i, v := range vv {
		if i > 0 {
			b.WriteString(", ")
		}
		b.WriteString(fn(v))
	}
	return b.String()
}

type method struct {
	typn string
	name string
	args vars
	rets vars
}

func (m *method) pname() string {
	return m.typn + m.name + "_P"
}

func (m *method) rname() string {
	return m.typn + m.name + "_R"
}

func vname(name string, attr string, n int) string {
	if name != "" {
		return name
	}
	return attr + strconv.Itoa(n)
}

func toPub(s string) string {
	if s == "" {
		return ""
	}
	_, n := utf8.DecodeRuneInString(s)
	p, r := s[:n], s[n:]
	return strings.ToUpper(p) + r
}

func filterMethods(src []*srcdom.Func, typname string) []*method {
	var dst []*method
	for _, f := range src {
		if !f.IsPublic() {
			continue
		}
		m := &method{typn: typname, name: f.Name}
		for i, p := range f.Params {
			m.args.add(&variable{
				name: vname(p.Name, "in", i),
				typ:  p.Type,
			})
		}
		for i, r := range f.Results {
			m.rets.add(&variable{
				name: vname(r.Name, "Out", i),
				typ:  r.Type,
			})
		}
		dst = append(dst, m)
	}
	return dst
}

func toStructType(typ string) string {
	if strings.HasPrefix(typ, "...") {
		return "[]" + typ[3:]
	}
	return typ
}

func generateMockType0(w io.Writer, mockTag, mockTypn, mockPkgn string, typ *srcdom.Type, pkg *srcdom.Package) error {
	origTypn := pkg.Name + "." + typ.Name
	methods := filterMethods(typ.Methods, mockTypn)
	if len(methods) == 0 {
		return fmt.Errorf("no methods in type:%s", typ.Name)
	}

	// write headers.
	if !forTest {
		fmt.Fprintf(w, "// +build %s\n\n", mockTag)
	}
	fmt.Fprintf(w, "// Code generated by github.com/koron/mockgo; DO NOT EDIT.\n\n")
	fmt.Fprintf(w, "package %s\n\n", mockPkgn)

	// write the mock type.
	fmt.Fprintf(w, "// %s is a mock of %s for test.\n", mockTypn, origTypn)
	fmt.Fprintf(w, "type %s struct {\n", mockTypn)
	for _, m := range methods {
		fmt.Fprintf(w, "\t%s_Ps []*%s\n", m.name, m.pname())
		fmt.Fprintf(w, "\t%s_Rs []*%s\n", m.name, m.rname())
	}
	fmt.Fprintf(w, "}\n")

	for _, m := range methods {
		fmt.Fprintf(w, "\n")

		// write parameter type for the method.
		fmt.Fprintf(w, "// %s packs input parameters of %s#%s method.\n", m.pname(), origTypn, m.name)
		fmt.Fprintf(w, "type %s struct {\n", m.pname())
		for _, a := range m.args {
			typ := toStructType(a.typ)
			fmt.Fprintf(w, "\t%s %s\n", toPub(a.name), typ)
		}
		fmt.Fprintf(w, "}\n\n")

		// write result type for the method.
		fmt.Fprintf(w, "// %s packs output parameters of %s#%s method.\n", m.rname(), origTypn, m.name)
		fmt.Fprintf(w, "type %s struct {\n", m.rname())
		for _, r := range m.rets {
			fmt.Fprintf(w, "\t%s %s\n", r.name, r.typ)
		}
		fmt.Fprintf(w, "}\n\n")

		// write mock func for the method.
		fmt.Fprintf(w, "// %s is mock of %s#%[1]s method.\n", m.name, origTypn)
		fmt.Fprintf(w, "func (_m *%s) %s(%s) (%s) {\n", mockTypn, m.name, m.args.nameTypes(), m.rets.types())
		fmt.Fprintf(w, "\t_m.%s_Ps = append(_m.%[1]s_Ps, &%s{%s})\n", m.name, m.pname(), m.args.names())
		fmt.Fprintf(w, "\tvar _r *%s\n", m.rname())
		fmt.Fprintf(w, "\t_r, _m.%[1]s_Rs = _m.%[1]s_Rs[0], _m.%[1]s_Rs[1:]\n", m.name)
		fmt.Fprintf(w, "\treturn %s\n", m.rets.namesPrefix("_r"))
		fmt.Fprintf(w, "}\n")
	}
	return nil
}

func path2pkgname(path string) (string, error) {
	p, err := filepath.Abs(path)
	if err != nil {
		return "", err
	}
	return filepath.Base(p), nil
}

func mockFilename(typn string) string {
	// if mocktype name ends with "mock", truncate it for filename.
	base := strings.ToLower(typn)
	if strings.HasSuffix(base, "mock") {
		base = base[0 : len(base)-4]
	}
	if forTest {
		return base + "_mock_test.go"
	}
	return base + "_mock.go"
}

func generateMockType(outdir, mockTypn string, applyFormat bool, typ *srcdom.Type, pkg *srcdom.Package) error {
	pkgn, err := path2pkgname(outdir)
	if err != nil {
		return err
	}

	fname := mockFilename(mockTypn)
	fpath := filepath.Join(outdir, fname)
	f, err := os.Create(fpath)
	if err != nil {
		return err
	}
	defer f.Close()
	bw := bufio.NewWriter(f)

	var w io.Writer = bw
	var bb *bytes.Buffer

	if applyFormat {
		bb = &bytes.Buffer{}
		w = bb
	}

	verbosef("writing %s for %s mock (%s)", fpath, typ.Name, mockTypn)
	err = generateMockType0(w, "mock", mockTypn, pkgn, typ, pkg)
	if err != nil {
		f.Close()
		os.Remove(fpath)
		return err
	}

	if bb != nil {
		b, err := imports.Process(fname, bb.Bytes(), nil)
		if err != nil {
			f.Close()
			os.Remove(fpath)
			return err
		}
		bw.Write(b)
	}

	err = bw.Flush()
	if err != nil {
		f.Close()
		os.Remove(fpath)
		return err
	}
	err = f.Sync()
	if err != nil {
		f.Close()
		os.Remove(fpath)
		return err
	}
	err = f.Close()
	if err != nil {
		os.Remove(fpath)
		return err
	}
	return nil
}

var (
	verbose    bool
	forTest    bool
	mockSuffix bool
	noFormat   bool
)

func gen() error {
	var (
		pkgname  string
		outdir   string
		typnames []string
	)
	flag.BoolVar(&forTest, "fortest", false, "generate mock for plain test, without +mock")
	flag.BoolVar(&mockSuffix, "mocksuffix", false, "add `Mock` suffix to generated mock types")
	flag.BoolVar(&noFormat, "noformat", false, "suppress to apply goimports")
	flag.StringVar(&outdir, "outdir", ".", "output directory")
	flag.StringVar(&pkgname, "package", "", "package name")
	flag.BoolVar(&verbose, "verbose", false, "show verbose/debug messages to stderr")
	flag.Parse()
	typnames = flag.Args()

	if pkgname == "" {
		return errors.New("need -package option")
	}
	if len(typnames) == 0 {
		return errors.New("need one or more type names")
	}

	// read source files, build srcdom.
	path := filepath.ToSlash(pkgname)
	if !strings.HasPrefix(path, "./") && !strings.HasPrefix(path, "../") {
		path = filepath.Join(build.Default.GOPATH, "src", pkgname)
	}
	pkg, err := srcdom.Read(path)
	if err != nil {
		return err
	}

	var errs errs
	for _, typn := range typnames {
		var mockTypn string
		if n := strings.IndexRune(typn, ':'); n >= 0 {
			typn, mockTypn = typn[:n], typn[n+1:]
		}
		typ, ok := pkg.Type(typn)
		if !ok {
			err := fmt.Errorf("not found type:%s, skipped", typn)
			errs.Append(err)
			log.Print(err)
			continue
		}
		if mockTypn == "" {
			mockTypn = typ.Name
			if mockSuffix {
				mockTypn += "Mock"
			}
		}
		err := generateMockType(outdir, mockTypn, !noFormat, typ, pkg)
		if err != nil {
			err2 := fmt.Errorf("failed to generate mock for %s: %s", typ.Name, err)
			errs.Append(err2)
			log.Print(err2)
			continue
		}
	}
	if len(errs) > 0 {
		return errs
	}
	verbosef("complete successfully")
	return nil
}

func verbosef(msg string, args ...interface{}) {
	if !verbose {
		return
	}
	log.Printf(msg, args...)
}

func main() {
	err := gen()
	if err != nil {
		log.Fatal(err)
	}
}
